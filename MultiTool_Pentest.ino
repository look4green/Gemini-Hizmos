// no not this one
// =======================================================
//                  MULTI TOOL DEVICE: PENTESTING SYSTEM
// =======================================================
// Target: ESP32-S3-N16R8
// Display: 1.3-inch OLED (U8G2)
// Core Features: 10-point menu system
// IR Module (Case 5) integrated.

// --- 0. LIBRARIES & EXTERNAL HEADERS ---
#include <stdint.h>
#include <Arduino.h>
#include <U8g2lib.h>
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
#include <Adafruit_NeoPixel.h>
#include <SD.h>
#include <Update.h>
#include <vector>
#include "USB.h"
#include "USBHIDKeyboard.h"
#include <BleMouse.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEScan.h>
#include <WiFi.h>
#include <IRremote.h>
#include <Wire.h>
#include <Adafruit_PN532.h>

// ESP32 System Headers
#include <esp_wifi.h>
#include "esp_heap_caps.h"
#include "esp_spi_flash.h"
#include "esp_chip_info.h"
#include "esp_system.h"

// --- 1. PIN DEFINITIONS ---
#define I2C_SDA 8
#define I2C_SCL 9
#define BTN_UP 4
#define BTN_DOWN 5
#define BTN_SELECT 6
#define BTN_BACK 7
#define BTN_LEFT 1
#define BTN_RIGHT 2
#define irsenderpin 41
#define irrecivepin 40
#define LED_PIN 48
#define LED_COUNT 1
#define PN532_IRQ 22
#define PN532_RESET 21
#define NRF_SCK 18
#define NRF_MISO 16
#define NRF_MOSI 17
#define CE1_PIN 10
#define CSN1_PIN 11
#define CE2_PIN 12
#define CSN2_PIN 13
#define CE3_PIN 20
#define CSN3_PIN 19
#define SD_SCK 14
#define SD_MISO 39
#define SD_MOSI 38
#define SD_CS 37
#define CC1101_CS_PIN 33
#define CC1101_GDO0_PIN 34
#define GPS_TX_PIN 15
#define GPS_RX_PIN 42
#define ANALOG_PIN 3
#define WAVE_OUT_PIN 48 // WARNING: Shared with LED_PIN

// --- 2. HARDWARE OBJECTS ---
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);
Adafruit_NeoPixel pixel(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);
Adafruit_PN532 nfc(PN532_IRQ, PN532_RESET, &Wire);
IRrecv irrecv(irrecivepin); // Super-Set IR object
IRsend irsend(irsenderpin); // Super-Set IR object
decode_results results;
SPIClass RADIO_SPI(FSPI);
SPIClass SD_SPI(HSPI);
RF24 radio1(CE1_PIN, CSN1_PIN);
RF24 radio2(CE2_PIN, CSN2_PIN);
RF24 radio3(CE3_PIN, CSN3_PIN);
USBHIDKeyboard Keyboard;
BleMouse mouse_ble("hizmos", "hizmos", 100);

// --- 3. GLOBAL STATE ---
int mainMenuIndex = 1;
const int MAX_MENU_INDEX = 10;
const int MIN_MENU_INDEX = 1;
bool autoMode = true;
unsigned long lastImageChangeTime = 0;
unsigned long lastButtonPressTime = 0;
const unsigned long autoModeTimeout = 120000;
int autoImageIndex = 0;
const int totalAutoImages = 406;
const int totalManualImages = 11;
const char* menuItems[] = {
    "1. WIFI ATTACKS", "2. BLE ATTACKS", "3. BAD USB", "4. NFC",
    "5. INFRARED", "6. SUB-GHZ", "7. 2.4GHZ RF", "8. APPS",
    "9. SETTINGS", "10. FILES"
};
// IR MODULE GLOBALS (Required for File/Capture state)
String irFileList[20];
int irFileCount = 0;
#define MAX_IR_RAW_LEN 1024
String irRawData = "";
#define MICROS_PER_TICK 50 // Required for IR remote timing conversion

// --- 4. BITMAPS & ANIMATIONS STUBS ---
// NOTE: These must be replaced with the actual array data from your system's files.
const uint8_t image_hizmos_oled_bits[] U8X8_PROGMEM = { 0x01 };
const uint8_t image_DolphinReadingSuccess_bits[] U8X8_PROGMEM = { 0x01 };
const uint8_t image_KeyBackspaceSelected_bits[] U8X8_PROGMEM = { 0x01 };
const uint8_t image_KeySaveSelected_bits[] U8X8_PROGMEM = { 0x01 };
const uint8_t image_Untitled_bits[] U8X8_PROGMEM = { 0x01 };
const uint8_t image_download_bits[] U8X8_PROGMEM = { 0x01 };
const uint8_t image_DolphinSaved_bits[] U8X8_PROGMEM = { 0x01 };
const uint8_t image_FILLED_bits[] U8X8_PROGMEM = { 0x01 };
const uint8_t autoImages[1] = {0x00}; // Placeholder for auto animation
const uint8_t config2[1] = {0x00}; // Placeholder for config screen
// Placeholder for dolphinreactions.h (not used in this simplified module)

// --- 5. FORWARD DECLARATIONS ---
void drawMainMenu();
void drawstartinfo();
void checksysdevices();
void showMessage(String msg);
void drawnosdcard();
void loading();
void runLoop(void (*func)());

// IR MODULE FORWARD DECLARATIONS
String inputName();
void replayRaw(String data);
void recvIR();
void listIRFiles();
void fileOptions(String filename);

// 10 MENU HANDLERS
void runWifiMenu();
void runBleMenu();
void runBadUsbMenu();
void runNfcMenu();
void runIRMenu(); // The new IR module top-level function
void runSubGhzMenu();
void runRF24Menu();
void runAppMenu();
void runSettingsMenu();
void runFilesMenu();

// =======================================================
//                  SYSTEM UTILITY FUNCTIONS
// =======================================================

void deactivateAllModules() {
    digitalWrite(SD_CS, HIGH);
    digitalWrite(CSN1_PIN, HIGH);
    digitalWrite(CSN2_PIN, HIGH);
    digitalWrite(CSN3_PIN, HIGH);
    digitalWrite(CC1101_CS_PIN, HIGH);
    digitalWrite(CE1_PIN, LOW);
    digitalWrite(CE2_PIN, LOW);
    digitalWrite(CE3_PIN, LOW);
}

void setColor(uint8_t r, uint8_t g, uint8_t b) {
    pixel.setPixelColor(0, pixel.Color(r, g, b));
    pixel.show();
}

void showMessage(String msg) {
    u8g2.clearBuffer();
    u8g2.setCursor(0, 20);
    u8g2.print(msg);
    u8g2.sendBuffer();
}

void drawnosdcard() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_haxrcorp4089_tr);
    u8g2.drawStr(10, 30, "NO SD CARD!");
    u8g2.sendBuffer();
    delay(1000);
}

void loading() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_haxrcorp4089_tr);
    u8g2.drawStr(10, 30, "LOADING...");
    u8g2.sendBuffer();
}

void displayImage(const uint8_t* image) {
    u8g2.clearBuffer();
    u8g2.drawXBMP(0, 0, 128, 64, image);
    u8g2.sendBuffer();
}

void displaymainanim(const uint8_t* image, int batteryPercent, bool sdOK) {
    u8g2.clearBuffer();
    u8g2.setDrawColor(1);
    u8g2.drawXBMP(0, 0, 128, 64, image);
    u8g2.setDrawColor(2); // XOR mode for overlay
    // Add battery/SD card drawing logic here
    u8g2.sendBuffer();
}

void runLoop(void (*func)()) {
    // This is the loop for sub-menus (e.g., IR Menu)
    unsigned long lastRun = millis();
    while (true) {
        if (millis() - lastRun > 130) {
            u8g2.clearBuffer();
            func(); // Run the submenu's draw/logic function
            lastRun = millis();
        }
        if (digitalRead(BTN_BACK) == LOW) {
            while (digitalRead(BTN_BACK) == LOW);
            break;
        }
    }
}

// =======================================================
//                  IR MODULE IMPLEMENTATION (CASE 5)
// =======================================================

// --- IR Core Logic ---
void replayRaw(String data) {
    const int maxLen = 200;
    uint16_t raw[maxLen];
    int index = 0;
    char buf[data.length() + 1];
    data.toCharArray(buf, sizeof(buf));
    char *token = strtok(buf, ",");
    while (token != NULL && index < maxLen) {
        raw[index++] = atoi(token);
        token = strtok(NULL, ",");
    }
    // irsend is globally defined in the Super-Set
    irsend.sendRaw(raw, index, 38);
}

// --- IR List/File Options Logic ---
void fileOptions(String filename) { /* ... (Logic from previous complete code) ... */ }
void listIRFiles() { /* ... (Logic from previous complete code) ... */ }
void inputName() { /* ... (Logic from previous complete code) ... */ }
void recvIR() { /* ... (Logic from previous complete code) ... */ }

// --- IR Top-Level Handler (Called by Main Menu) ---
void runIRMenu() {
    static int irSubMenuIndex = 0;
    String irSubMenuItems[] = {"Capture New Signal", "View Saved Signals"};
    const int count = 2;

    // Draw IR Submenu
    u8g2.setFont(u8g2_font_6x10_tf);
    u8g2.drawStr(0, 10, "--- INFRARED MODULE ---");

    for (int i = 0; i < count; i++) {
        int y = 20 + i * 12;
        if (i == irSubMenuIndex) {
            u8g2.drawRBox(0, y - 10, 128, 12, 0);
            u8g2.setDrawColor(0);
        } else {
            u8g2.setDrawColor(1);
        }
        u8g2.setCursor(3, y);
        u8g2.print(irSubMenuItems[i]);
    }
    u8g2.setDrawColor(1);
    u8g2.sendBuffer();

    // Handle Buttons
    if (digitalRead(BTN_UP) == LOW) { irSubMenuIndex = (irSubMenuIndex + count - 1) % count; delay(150); }
    if (digitalRead(BTN_DOWN) == LOW) { irSubMenuIndex = (irSubMenuIndex + 1) % count; delay(150); }

    if (digitalRead(BTN_SELECT) == LOW) {
        while (digitalRead(BTN_SELECT) == LOW);
        if (irSubMenuIndex == 0) {
            runLoop(recvIR); // Enter Capture mode
        } else if (irSubMenuIndex == 1) {
            runLoop(listIRFiles); // Enter File Browser
        }
    }
}

// =======================================================
//                  10 MODULE HANDLERS (PLACEHOLDERS)
// =======================================================

void runWifiMenu() { u8g2.setCursor(0, 30); u8g2.print("1. WiFi Module"); u8g2.sendBuffer(); }
void runBleMenu() { u8g2.setCursor(0, 30); u8g2.print("2. BLE Module"); u8g2.sendBuffer(); }
void runBadUsbMenu() { u8g2.setCursor(0, 30); u8g2.print("3. BadUSB Module"); u8g2.sendBuffer(); }
void runNfcMenu() { u8g2.setCursor(0, 30); u8g2.print("4. NFC Module"); u8g2.sendBuffer(); }
// Case 5: runIRMenu is defined above

void runSubGhzMenu() { u8g2.setCursor(0, 30); u8g2.print("6. Sub-GHz Module"); u8g2.sendBuffer(); }
void runRF24Menu() { u8g2.setCursor(0, 30); u8g2.print("7. 2.4GHz RF Module"); u8g2.sendBuffer(); }
void runAppMenu() { u8g2.setCursor(0, 30); u8g2.print("8. Apps Menu"); u8g2.sendBuffer(); }
void runSettingsMenu() { u8g2.setCursor(0, 30); u8g2.print("9. Settings Menu"); u8g2.sendBuffer(); }
void runFilesMenu() { u8g2.setCursor(0, 30); u8g2.print("10. Files Browser"); u8g2.sendBuffer(); }


// =======================================================
//                    MAIN MENU & LOOP LOGIC
// =======================================================

void drawMainMenu() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_6x10_tf);
    u8g2.drawStr(0, 10, "--- MULTI TOOL ---");

    int startItem = max(MIN_MENU_INDEX, mainMenuIndex - 2);
    int endItem = min(MAX_MENU_INDEX, startItem + 4);

    for (int i = startItem; i <= endItem; i++) {
        int displayY = 20 + (i - startItem) * 8;
        if (i == mainMenuIndex) {
            u8g2.drawRBox(0, displayY - 8, 128, 9, 0);
            u8g2.setDrawColor(0);
            u8g2.setCursor(3, displayY);
            u8g2.print(">");
            u8g2.print(menuItems[i - 1]);
            u8g2.setDrawColor(1);
        } else {
            u8g2.setCursor(3, displayY);
            u8g2.print(menuItems[i - 1]);
        }
    }
    u8g2.sendBuffer();
}

void handleButtonPress() {
    if (digitalRead(BTN_UP) == LOW) {
        while (digitalRead(BTN_UP) == LOW);
        mainMenuIndex = max(MIN_MENU_INDEX, mainMenuIndex - 1);
        lastButtonPressTime = millis();
    }
    if (digitalRead(BTN_DOWN) == LOW) {
        while (digitalRead(BTN_DOWN) == LOW);
        mainMenuIndex = min(MAX_MENU_INDEX, mainMenuIndex + 1);
        lastButtonPressTime = millis();
    }
    // Handle LEFT/RIGHT for future use
    if (digitalRead(BTN_SELECT) == LOW) {
        while (digitalRead(BTN_SELECT) == LOW);

        switch (mainMenuIndex) {
            case 1: runLoop(runWifiMenu); break;
            case 2: runLoop(runBleMenu); break;
            case 3: runLoop(runBadUsbMenu); break;
            case 4: runLoop(runNfcMenu); break;
            case 5: runLoop(runIRMenu); break; // IR Module Entry Point
            case 6: runLoop(runSubGhzMenu); break;
            case 7: runLoop(runRF24Menu); break;
            case 8: runLoop(runAppMenu); break;
            case 9: runLoop(runSettingsMenu); break;
            case 10: runLoop(runFilesMenu); break;
            default: break;
        }
    }
}

void handlemainmenu() {
    handleButtonPress();
    drawMainMenu();
}

void autoModeCheck() {
    if (digitalRead(BTN_UP) == LOW || digitalRead(BTN_DOWN) == LOW || digitalRead(BTN_SELECT) == LOW || digitalRead(BTN_BACK) == LOW) {
        autoMode = false;
        lastButtonPressTime = millis();
    }
    if (!autoMode && millis() - lastButtonPressTime > autoModeTimeout) {
        autoMode = true;
    }
}

void drawstartinfo() {
  // Placeholder: Displays system info on startup
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.drawStr(0, 10, "MULTI TOOL V1.0");
  u8g2.drawStr(0, 25, "Target: ESP32-S3");
  u8g2.sendBuffer();
}

void checksysdevices() {
    // Placeholder: Checks and reports status of peripherals
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_6x10_tf);
    u8g2.drawStr(0, 10, "DEVICE CHECK:");
    u8g2.drawStr(0, 20, SD.begin(SD_CS, SD_SPI) ? "SD: OK" : "SD: FAIL");
    u8g2.drawStr(0, 30, nfc.getFirmwareVersion() ? "NFC: OK" : "NFC: FAIL");
    // Add checks for radio1, radio2, etc.
    u8g2.sendBuffer();
}

// =======================================================
//                  SETUP & LOOP
// =======================================================

void setup() {
    Serial.begin(9600);

    // --- 1. Pin Modes ---
    pinMode(BTN_UP, INPUT_PULLUP);
    pinMode(BTN_DOWN, INPUT_PULLUP);
    pinMode(BTN_SELECT, INPUT_PULLUP);
    pinMode(BTN_BACK, INPUT_PULLUP);
    pinMode(BTN_LEFT, INPUT_PULLUP);
    pinMode(BTN_RIGHT, INPUT_PULLUP);
    pinMode(WAVE_OUT_PIN, OUTPUT);
    pinMode(CC1101_CS_PIN, OUTPUT);
    pinMode(CC1101_GDO0_PIN, INPUT);

    pinMode(SD_CS, OUTPUT);
    pinMode(CSN1_PIN, OUTPUT);
    pinMode(CSN2_PIN, OUTPUT);
    pinMode(CSN3_PIN, OUTPUT);
    pinMode(CE1_PIN, OUTPUT);
    pinMode(CE2_PIN, OUTPUT);
    pinMode(CE3_PIN, OUTPUT);

    deactivateAllModules();

    // --- 2. I2C/OLED/NFC ---
    Wire.begin(I2C_SDA, I2C_SCL);
    u8g2.begin();
    u8g2.setFont(u8g2_font_6x10_tf);
    nfc.begin();
    nfc.SAMConfig();

    // --- 3. SPI Buses ---
    RADIO_SPI.begin(NRF_SCK, NRF_MISO, NRF_MOSI);
    SD_SPI.begin(SD_SCK, SD_MISO, SD_MOSI);

    // --- 4. RF and IR ---
    irrecv.begin(irrecivepin);
    irsend.begin(irsenderpin);
    // radio1.begin(&RADIO_SPI); // Uncomment if modules are wired
    // radio2.begin(&RADIO_SPI);
    // radio3.begin(&RADIO_SPI);

    // --- 5. Other Modules ---
    pixel.begin();
    pixel.setBrightness(80);
    pixel.show();
    USB.begin();
    Keyboard.begin();
    mouse_ble.begin();

    // --- 6. Initial Display ---
    drawstartinfo();
    delay(1000);
    checksysdevices();
    delay(1000);
}

void loop() {
    handleButtonPress();
    autoModeCheck();
    setColor(0, 0, 0);

    if (autoMode) {
        if (millis() - lastImageChangeTime > 300) {
            autoImageIndex = (autoImageIndex + 1) % totalAutoImages;
            lastImageChangeTime = millis();
        }
        displaymainanim(autoImages[autoImageIndex], 87, true);
    } else {
        handlemainmenu();
    }
}

// NOTE: The full bodies of inputName, recvIR, listIRFiles, and fileOptions 
// must be pasted into the placeholder functions above for 100% functionality.
